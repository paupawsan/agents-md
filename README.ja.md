<!--
Copyright (c) 2025 Paulus Ery Wasito Adhi paupawsan@gmail.com

Licensed under the MIT License. See LICENSE file for details.
-->

# agents-md

AIコーディングエージェント向けのシステムとツールのコレクション。実務経験に基づいて構築されています。現在は堅牢なメモリシステムを含み、将来的にはさらに多くのシステムが追加される予定です。

## 概要

**agents-md**は、AIコーディングエージェントの能力を向上させる実用的なシステムとツールの成長するコレクションです。各システムは実務経験と本番環境での使用事例に基づいて開発されています。

**現在の状況**: メモリシステムが最初に利用可能なシステムです。実用的なアプリケーションを通じて開発・改良されるにつれて、追加のシステムが時間をかけて追加されます。

## 🚀 クイックスタート

**初心者ですか？プログラマーではないですか？** → **[SIMPLE_SETUP.ja.md](SIMPLE_SETUP.ja.md)** から始めてください - 平易な言葉で書かれたステップバイステップガイドで、技術者以外の方に最適です。

**経験豊富な開発者ですか？** → 下の[メモリシステムセットアップ](#メモリシステムセットアップ)セクションにジャンプしてください。

### やること（簡単版）

1. **ファイルを取得** - このリポジトリをダウンロードまたはクローン
2. **名前を選択** - メモリフォルダのシンプルな名前を選ぶ（例：`my-memory`）
3. **AGENTS.mdを設定** - テンプレートをコピーしてプレースホルダーを1つ置き換える
4. **プロジェクトで設定** - どちらか：
   - **オプションA（簡単）**: `agents-md`フォルダをワークスペースに追加 - Cursor/VS Codeが`AGENTS.md`を自動的に検出
   - **オプションB**: ファイルをプロジェクトフォルダにコピー
5. **メモリの場所を選択** - メモリを保存する場所を決める（通常はDocumentsフォルダ）
6. **ワークスペースに追加** - メモリフォルダをCursor/VS Codeワークスペースに追加
7. **テスト** - AIにメモリを初期化するよう依頼

**以上です！** [SIMPLE_SETUP.ja.md](SIMPLE_SETUP.ja.md)の詳細ガイドでは、各ステップをスクリーンショットの説明とトラブルシューティングのヒント付きで説明しています。

**💡 ヒント**: CursorまたはVS Codeを使用している場合、ワークスペースベースのセットアップ（オプションA）の方がはるかに簡単です - 各プロジェクトに`AGENTS.md`をコピーする必要がありません！

### 利用可能なシステム

#### 🧠 メモリシステム（現在）

マルチプラットフォーム対応の堅牢なRAG最適化メモリ管理システム。AIコーディングエージェント向けに、プロジェクト固有の知識、ユーザー設定、クロスプロジェクトパターンを体系的に保存・取得する方法を提供します。

**注意**: メモリディレクトリ名はユーザーが設定可能です。このドキュメント全体で、`{MEMORY_DIR}`は選択したディレクトリ名を表します（例：`agent-memory`、`my-memory`、`ai-memory`など）。システムを設定する際は、`{MEMORY_DIR}`を選択した名前に置き換えてください。

**ワークフローオプション**:
- **構造化ワークフロー**: `topic/`、`session/`、インデックスを含む完全なメモリシステム（複雑なプロジェクトに最適）
- **シンプルワークフロー**: クイックな日次ログ用の単一ファイルテンプレート（vibecodingや実験に最適）
- `templates/README.md`でテンプレートとワークフロー選択のガイダンスを参照

### 将来のシステム

実務経験と実用的なニーズに基づいて、さらに多くのシステムが追加されます。各システムは以下を満たします：
- **本番テスト済み**: 実世界での使用を通じて開発・改良
- **十分にドキュメント化**: 包括的なドキュメントと例
- **モジュール化**: 独立して使用可能、または他のシステムと組み合わせ可能
- **エージェント互換**: AIコーディングエージェントとシームレスに動作するよう設計

---

## メモリシステム

以下のセクションでは、現在利用可能なメモリシステムをドキュメント化します。

**🚀 主な機能**:
- **高度なRAGサポート**: マルチレベルインデックスによるインテリジェントなセマンティック検索
- **トークン最適化**: 選択的読み取りとインデックスによる80-95%のトークン削減
- **マルチプラットフォーム**: macOS、Linux、Windowsのネイティブサポートとプラットフォーム固有の最適化
- **高速取得**: マルチレベルインデックスとキャッシュ戦略による即座のアクセス
- **スケーラブル**: パフォーマンス低下なしで大規模なメモリデータベースを処理

**✅ 互換性**: 既存のCursorルール、ユーザールール、カスタム`AGENTS.md`設定と完全に互換性があります。既存のセットアップにメモリシステムルールを追加するだけです。

**🌐 マルチエージェントサポート**: 技術的には、Cursor、Aider、GitHub Copilotなど、`AGENTS.md`形式をサポートする任意のコーディングエージェントやエディタと互換性があります。

### ⚠️ モデル互換性に関する注意

**重要**: すべてのAIモデルがメモリ管理をスマートにサポートできるわけではありません。このシステムは、以下を実行できる**エージェント対応モデル**向けに設計されています：
- 複雑な指示を理解し、従う
- セマンティック検索と取得を実行
- どの情報を読み込むかについてインテリジェントな決定を行う
- 自律的にマルチステップワークフローを実行

**推奨**: 最適なメモリシステムパフォーマンスのために、エージェント対応モデル（Claude Sonnet/Opus、GPT-4、または同様の高度なモデルなど）を使用してください。

## なぜローカルMarkdownファイルなのか？

MCP（Model Context Protocol）ツール、データベース、ベクトルストア、セキュリティや機能が強化されたクラウドベースシステムなど、多くのメモリソリューションが利用可能です。では、なぜローカルMarkdownファイルを選ぶのでしょうか？

### 設計哲学

**agents-md**は、高度な技術機能よりも**人間の可読性、透明性、制御**を優先します。理由は以下の通りです：

### 人間にとっての利点

#### 1. **完全な透明性と制御**
- ✅ **すべてを読める**: すべてのメモリは人間が読めるMarkdownファイルに保存されます
- ✅ **データを所有**: ファイルはローカルに保存され、クラウドサービスやデータベースには保存されません
- ✅ **簡単な検査**: 任意のメモリファイルを開いて、エージェントが何を知っているかを正確に確認できます
- ✅ **ブラックボックスなし**: 隠れたデータベースや独自形式はありません

#### 2. **簡単な編集とメンテナンス**
- ✅ **任意のテキストエディタで編集**: VS Code、Cursor、vim、さらにはNotepadも使用可能
- ✅ **バージョン管理に適している**: MarkdownファイルはGitと完璧に連携します
- ✅ **簡単なバックアップ**: ディレクトリをコピーするだけ - データベースエクスポートは不要
- ✅ **ポータブル**: ファイルをコピーしてマシン間でメモリを移動

#### 3. **学習と理解**
- ✅ **パターンの出現を確認**: 知識ファイルを閲覧して、エージェントが学習した内容を理解
- ✅ **決定のレビュー**: セッションアーカイブを読んで、問題がどのように解決されたかを確認
- ✅ **インタラクション履歴の分析**: 過去の会話と作業セッションをレビューして、コラボレーションパターンを理解し、繰り返し発生する問題を特定し、ワークフローを改善
- ✅ **知識の移転**: チームメンバーや新しいプロジェクトとメモリファイルを共有
- ✅ **ドキュメント**: メモリファイルはプロジェクトの生きたドキュメントとして機能

#### 4. **依存関係なし**
- ✅ **データベースセットアップ不要**: PostgreSQL、MongoDB、SQLiteは不要
- ✅ **APIキー不要**: 外部サービスや認証は不要
- ✅ **インストール不要**: ファイルだけ - どこでも動作
- ✅ **ベンダーロックインなし**: メモリはサービスに紐付けられません

#### 5. **プライバシーとセキュリティ**
- ✅ **ローカルストレージ**: メモリはマシン（またはクラウドストレージ）に保存されます
- ✅ **データ送信なし**: メモリを外部サービスに送信するAPI呼び出しはありません
- ✅ **アクセス制御**: ファイルシステム権限、暗号化、またはセキュアなクラウドストレージを使用
- ✅ **監査証跡**: 何がいつ保存されたかを正確に確認

### エージェントにとっての利点

#### 1. **効率的なRAG取得**
- ✅ **セマンティック検索**: エージェントは`codebase_search`を使用して関連メモリを検索
- ✅ **選択的読み取り**: ファイル全体ではなく、関連セクションのみを読み取り
- ✅ **トークン最適化**: すべてのメモリを読み込む場合と比較して80-95%のトークン使用量削減
- ✅ **高速ルックアップ**: インデックスファイルによりメモリメタデータへの即座のアクセス

#### 2. **構造化された組織化**
- ✅ **明確な分類**: プロジェクト固有、共有、セキュアなメモリの分離
- ✅ **セマンティックタグ**: タグとキーワードによりインテリジェントな取得を可能に
- ✅ **期間ベースのアーカイブ**: 効率的な履歴検索のために時間で整理されたセッション
- ✅ **知識とセッション**: パターンと作業履歴の明確な分離

#### 3. **プラットフォーム認識**
- ✅ **クロスプラットフォーム**: macOS、Linux、Windowsで動作
- ✅ **クラウドストレージサポート**: Google Drive、iCloudなどを検出して使用
- ✅ **パス解決**: プラットフォーム固有のパス処理の自動化
- ✅ **ツール最適化**: 最高のパフォーマンスのためにプラットフォーム固有のツールを使用

#### 4. **スケーラビリティ**
- ✅ **大規模メモリを処理**: インデックス優先アプローチによりパフォーマンス低下を防止
- ✅ **チャンク取得**: 管理可能なピースでメモリを処理
- ✅ **効率的な検索**: 高速ルックアップのためのマルチレベルインデックス
- ✅ **サイズ制限なし**: 一部のデータベースソリューションとは異なり、実用的なサイズ制約はありません

### 他のソリューションとの比較

| 機能 | ローカルMarkdown | MCPツール | データベース | クラウドサービス |
|---------|---------------|-----------|-----------|----------------|
| **人間が読める** | ✅ はい | ❌ いいえ | ❌ いいえ | ❌ いいえ |
| **依存関係なし** | ✅ はい | ❌ いいえ | ❌ いいえ | ❌ いいえ |
| **バージョン管理** | ✅ 優秀 | ⚠️ 限定的 | ⚠️ 限定的 | ❌ いいえ |
| **プライバシー** | ✅ 完全制御 | ⚠️ 依存 | ⚠️ 依存 | ❌ 外部 |
| **ポータビリティ** | ✅ 優秀 | ⚠️ 中程度 | ⚠️ 中程度 | ❌ 低い |
| **セットアップの複雑さ** | ✅ 最小限 | ⚠️ 中程度 | ❌ 高い | ⚠️ 中程度 |
| **RAGサポート** | ✅ 優秀 | ✅ 優秀 | ⚠️ 中程度 | ✅ 優秀 |
| **トークン効率** | ✅ 優秀 | ✅ 優秀 | ⚠️ 中程度 | ✅ 優秀 |

### agents-mdを使用する場合

**agents-mdを選択する場合**:
- メモリに対する完全な透明性と制御を望む
- 人間が読める、編集可能なファイルを好む
- 簡単なバックアップとポータビリティが必要
- 外部依存関係を避けたい
- プライバシーとローカルストレージを重視
- バージョン管理システムで作業

**代替案を検討する場合**:
- リアルタイムコラボレーション機能が必要
- 高度なクエリ機能（SQL、複雑な結合）が必要
- ストレージレベルでの組み込み暗号化が必要
- データベースストレージに関する特定のコンプライアンス要件がある
- 管理されたクラウドソリューションを好む

### 両方の世界のベスト

**agents-md**は他のツールの使用を妨げません。以下が可能です：
- 特定の機能にMCPツールを使用しながら、一般的なメモリにMarkdownを使用
- パターンをMarkdownに保持しながら、機密データを暗号化データベースに保存
- プライマリストレージとしてローカルMarkdownを維持しながら、バックアップにクラウドサービスを使用
- ニーズに基づいて複数のアプローチを組み合わせ

目標は、**シンプルで透明性が高く、強力な**基盤を提供し、ほとんどのユースケースでうまく機能し、必要に応じて他のツールと統合できる柔軟性を維持することです。

## メモリシステムのセットアップ

> **💡 技術者以外の方へ**: コマンドラインツールや専門用語に慣れていない場合は、**[SIMPLE_SETUP.ja.md](SIMPLE_SETUP.ja.md)**ガイドを使用してください。平易な言葉でのステップバイステップの説明を提供します。

このセクションは開発者向けの技術的なセットアップ手順を提供します。セットアッププロセスには、ファイルパスの設定、ファイルのコピー、ワークスペースアクセスの設定が含まれます。

### 1. メモリリポジトリのクローンまたは初期化

まず、このリポジトリをクローンするか、メモリストレージの場所を設定します：

```bash
git clone <repository-url>
cd agents-md
```

または、新しいインスタンスを設定する場合：

```bash
mkdir -p ~/Documents/agents-md
cd ~/Documents/agents-md
```

**⚠️ 重要**: メモリディレクトリ名（例：`agent-memory`、`my-memory`、`ai-memory`）を選択し、`AGENTS.md`で設定します（以下のステップ2を参照）。

### 2. メモリディレクトリ名の設定

**重要**: `AGENTS.md`の`{MEMORY_DIR}`プレースホルダーを選択したディレクトリ名に置き換える必要があります。

> **💡 ヒント**: 検索置換に慣れていない場合は、詳細な視覚的な説明については[SIMPLE_SETUP.ja.md](SIMPLE_SETUP.ja.md)を参照してください。

#### オプションA: 手動置換（非エンジニア向け推奨）

**これは簡単で分かりやすい** - テキストエディタで検索置換を使用するだけです：

1. テキストエディタで`AGENTS.md`を開く
2. 検索置換を使用（通常は`Cmd+F`または`Ctrl+F`）：
   - 検索: `{MEMORY_DIR}`
   - 置換: `your-chosen-name`（例：`agent-memory`、`my-memory`など）
3. すべての出現箇所を置換
4. ファイルを保存

**これだけです！** 手動置換はシンプルで完璧に機能します。

#### オプションB: Pythonスクリプト（エンジニア向け）

自動化を好む場合は、提供されているPythonスクリプトを使用できます：

```bash
python3 setup_memory_dir.py
```

スクリプトは以下を実行します：
- 選択したディレクトリ名をプロンプト
- 名前を検証（小文字、数字、ハイフン、アンダースコアのみ）
- `AGENTS.md`のすべての`{MEMORY_DIR}`出現箇所を置換
- 変更の概要を表示

**注意**: スクリプトにはPython 3.6+が必要です。Pythonやコマンドラインツールに慣れていない場合は、代わりにオプションA（手動置換）を使用してください - 同様に効果的で簡単です。

### 3. プロジェクトでファイルを設定

プロジェクトでメモリシステムを設定するには2つのオプションがあります：

#### オプションA: ワークスペースベースのセットアップ（Cursor/VS Code推奨）

**エディタがワークスペースをサポートしている場合**（CursorやVS Codeなど）、ファイルをコピーする代わりに、クローンした`agents-md`リポジトリを直接ワークスペースに追加できます：

1. **agents-mdをワークスペースに追加**:
   - コマンドパレットを開く（`Cmd+Shift+P` / `Ctrl+Shift+P`）
   - 「Add Folder to Workspace」を選択
   - クローンした`agents-md`フォルダに移動して選択
   - `agents-md`フォルダがワークスペースサイドバーに表示されます

2. **AGENTS.mdが自動的に検出されます**:
   - 最近のバージョンのCursorは、ワークスペース内の`AGENTS.md`ファイルを自動的に検出します
   - `agents-md`フォルダ内の`AGENTS.md`ファイルがアクティブルールとして使用されます
   - `AGENTS.md`をプロジェクトルートにコピーする必要はありません

3. **`_agents-md`フォルダをコピー**（まだ必要）:
   - `_agents-md`フォルダをプロジェクトルートにコピーする必要があります、または
   - ワークスペースにも追加できます（`agents-md`フォルダからアクセス可能になります）

**このアプローチの利点**:
- ✅ 各プロジェクトに`AGENTS.md`をコピーする必要がない
- ✅ 更新が簡単 - `agents-md`リポジトリの変更が自動的に適用される
- ✅ よりクリーンなプロジェクト構造 - 重複ファイルがない
- ✅ 同じセットアップを共有する複数のプロジェクトでうまく機能する

#### オプションB: プロジェクトにファイルをコピー（従来の方法）

**以下をプロジェクトルートにコピー**：

1. **`_agents-md`フォルダをコピー** - メモリシステムプロンプトとガイドラインを含む
2. **`AGENTS.md`をコピー** - エージェントルールとメモリ設定を含む（選択したディレクトリ名で既に設定済み）

**コマンドラインを使用**:
```bash
# プロジェクトルートから
cp -r /path/to/agents-md/_agents-md .
cp /path/to/agents-md/AGENTS.md ./AGENTS.md
```

**ファイルマネージャーを使用**（技術者以外の方には簡単）:
- `agents-md`フォルダに移動
- `_agents-md`フォルダと`AGENTS.md`ファイルをコピー
- プロジェクトフォルダに移動
- 両方を貼り付け

> **💡 詳細なファイルコピー手順については**、[SIMPLE_SETUP.ja.md](SIMPLE_SETUP.ja.md)のステップ4を参照してください。

**重要**: プロジェクトに既に`AGENTS.md`ファイルがある場合、競合を避けるために、agents-mdの`AGENTS.md`の内容を既存のファイルに**追加**してください。

**✅ 互換性に関する注意**: agents-mdは既存のCursorルールとユーザールールと完全に互換性があります。メモリシステムルールは既存の`AGENTS.md`コンテンツと並行して動作します。

### 3.5. 言語選択（オプション）

**AGENTS.md**は英語と日本語の両方をサポートしています。自動スクリプトまたは手動セットアップのいずれかを使用して、希望する言語を選択できます。

#### オプションA: 自動スクリプト（推奨）

提供されているPythonスクリプトを使用して言語を切り替えます：

```bash
# 日本語に切り替え
python3 switch_agents_lang.py ja

# 英語に切り替え
python3 switch_agents_lang.py en

# 現在の言語を確認
python3 switch_agents_lang.py
```

スクリプトは別々のソースファイル（`AGENTS.md.en`と`AGENTS.md.ja`）を維持し、選択に基づいて適切なものを`AGENTS.md`にコピーします。

#### オプションB: 手動セットアップ（簡単な代替方法）

手動セットアップを希望する場合、またはスクリプトを使用したくない場合は、テンプレートファイルを手動でクローンして名前を変更できます：

**英語の場合**:
```bash
# 英語テンプレートをAGENTS.mdにコピー
cp AGENTS.md.en AGENTS.md
```

**日本語の場合**:
```bash
# 日本語テンプレートをAGENTS.mdにコピー
cp AGENTS.md.ja AGENTS.md
```

**注意**: プロジェクトルートに単一の`AGENTS.md`ファイルを保持するという考え方です。`AGENTS.md.en`と`AGENTS.md.ja`ファイルは、言語の好みに基づいて`AGENTS.md`にクローンして名前を変更するテンプレートとして機能します。

**重要**: 手動でコピーした後、必ず以下を確認してください：
1. コピーした`AGENTS.md`の`{MEMORY_DIR}`プレースホルダーを置き換える（まだ行っていない場合）
2. `AGENTS.md`でメモリパスを設定する（ステップ4を参照）

**注意**: 言語切り替えは`AGENTS.md`にのみ影響します。ドキュメントファイル（`README.md`など）には、エージェント機能に影響しない別々の日本語版（例：`README.ja.md`）があります。

### 4. AGENTS.mdでメモリパスを設定

**重要**: プロジェクトに`AGENTS.md`をコピーした後、ローカルシステムとプラットフォームに合わせてメモリストレージパスを調整する必要がある場合があります。

1. プロジェクトルートで`AGENTS.md`を開く
2. メモリストレージパスセクション（プラットフォーム検出）を見つける
3. 必要に応じてパスをシステムに合わせて更新

**プラットフォーム固有の例**（`{MEMORY_DIR}`プレースホルダーはステップ2で選択した名前に既に置き換えられている必要があります）：
- **macOS**: `~/Library/CloudStorage/GoogleDrive-you@gmail.com/My Drive/AI/your-memory-dir`または`~/Documents/your-memory-dir`
- **Linux**: `~/Documents/your-memory-dir`または`~/.local/share/your-memory-dir`
- **Windows**: `%USERPROFILE%\Documents\your-memory-dir`または`%APPDATA%\your-memory-dir`

**注意**: デフォルトパスはほとんどのユーザーで機能します。カスタムセットアップがある場合のみ調整してください。

### 5. ワークスペースにメモリディレクトリを追加（Cursor/VS Code）

**重要**: CursorとVS Codeはデフォルトではワークスペース外のファイルにアクセスできません。メモリシステムのファイルアクセス権限を有効にするには、メモリディレクトリをプロジェクトワークスペースに**追加する必要があります**。

> **💡 このステップのヘルプが必要ですか？** 詳細な手順とトラブルシューティングのヒントについては、[SIMPLE_SETUP.ja.md](SIMPLE_SETUP.ja.md)のステップ6を参照してください。

#### これが必要な理由

- **ファイルアクセスの制限**: Cursor/VS Codeエージェントはセキュリティ上の理由から、ワークスペース内のファイルにのみアクセスできます
- **メモリの場所**: メモリディレクトリは通常、プロジェクト外（例：`~/Documents/`やクラウドストレージ）に保存されます
- **解決策**: メモリディレクトリをワークスペースに追加することで、ファイルアクセス権限が昇格し、エージェントがメモリファイルを読み書きできるようになります

#### 方法1: コマンドパレットを使用（最も簡単）

**Cursor/VS Codeで**:
1. コマンドパレットを開く：
   - **macOS**: `Cmd+Shift+P`
   - **Windows/Linux**: `Ctrl+Shift+P`
2. 入力して選択: **"Add Folder to Workspace"**または**"Workspaces: Add Folder to Workspace"**
3. メモリディレクトリ（`AGENTS.md`で設定されたディレクトリ）に移動して選択
   - 例: `~/Library/CloudStorage/GoogleDrive-you@gmail.com/My Drive/AI/your-memory-dir`
   - または: `~/Documents/your-memory-dir`
4. メモリディレクトリがワークスペースサイドバーに別のフォルダとして表示されます

#### 方法2: ワークスペースファイルを使用（マルチフォルダワークスペース用）

`.code-workspace`ファイルを介してワークスペースを管理する場合：

1. プロジェクトルートに`.code-workspace`ファイルを作成または編集：
```json
{
  "folders": [
    {
      "path": "."
    },
    {
      "path": "/Users/username/Documents/your-memory-dir"
    }
  ],
  "settings": {}
}
```

2. 2番目の`path`を実際のメモリディレクトリパスに置き換える
3. ワークスペースファイルを開く: `File > Open Workspace from File...`を選択し、`.code-workspace`ファイルを選択

#### 方法3: ワークスペース設定を使用（代替方法）

1. コマンドパレットを開く（`Cmd+Shift+P` / `Ctrl+Shift+P`）
2. 入力: **"Preferences: Open Workspace Settings"**
3. メモリディレクトリパスをワークスペース設定に追加（エディタのバージョンでサポートされている場合）

#### 確認

メモリディレクトリをワークスペースに追加した後：
- ✅ メモリディレクトリがワークスペースサイドバーに表示されるはずです
- ✅ エディタでメモリファイルを閲覧できるはずです
- ✅ エージェントがメモリファイルを読み書きできるようになります

**注意**: クラウドストレージ（Google Drive、iCloudなど）を使用している場合、ワークスペースに追加する前に、パスがアクセス可能でディレクトリが存在することを確認してください。

### 6. プロジェクトのメモリを初期化

現在のプロジェクトのメモリ構造を初期化するには、エージェントが理解する任意の自然言語プロンプトを使用します。例：

**英語**:
```
construct memory
initialize memory for this project
set up project memory
create memory structure
```

**日本語**:
```
メモリを構築
このプロジェクトのメモリを初期化
プロジェクトメモリをセットアップ
メモリ構造を作成
```

エージェントは、設定されたメモリディレクトリにメモリ構造を自動的に作成し、インデックスファイルとプロジェクトアーキテクチャとパターンをドキュメント化する初期知識ファイルを含めます。

### 7. 設定の確認

以下を確認してください：
- プロジェクトルートに`_agents-md`フォルダが存在する
- プロジェクトルートに`AGENTS.md`が存在する（`{MEMORY_DIR}`が選択した名前に置き換えられている）
- `AGENTS.md`のメモリパスがメモリディレクトリを指している
- メモリディレクトリがCursorワークスペースに追加されている
- メモリディレクトリが存在し、書き込み可能である

## メモリシステムの使用

### メモリ構造

メモリシステムは情報を3つのカテゴリに整理します：

1. **プロジェクト固有のメモリ** (`{MEMORY_DIR}/[project-name]/`)
   - プロジェクトアーキテクチャの決定
   - プロジェクト固有のパターンと修正
   - プロジェクトファイルの場所
   - プロジェクト固有の設定

2. **共通メモリ** (`{MEMORY_DIR}/shared/`)
   - ユーザー設定（すべてのプロジェクトに適用）
   - グローバル設定と構成
   - クロスプロジェクトパターン
   - ユーザーワークフロー

3. **プライベートメモリ** (`{MEMORY_DIR}/secure/`) ⚠️
   - APIキー、パスワード、トークン
   - 個人情報
   - 機密設定
   - **バージョン管理にコミットしないでください**

### エージェントがメモリを使用する方法

エージェントは自動的に：
- **メモリを同期** - 重要なタスクの後、またはパターンを学習する際
- **メモリを確認** - コンテキストが失われた場合、または不明確な場合
- **インデックスファイルを更新** - 新しい知識やセッションを作成する際
- **関連セッションを統合** - クリーンな組織化を維持
- **RAGを使用** - 関連メモリのみを取得し、トークン使用量を最小化

**注意**: Cursorエージェントは会話中に自動的にメモリを同期します。通常、手動同期は不要ですが、手動でトリガーしたい場合は以下のプロンプトが提供されます。

### 🚀 高度なRAG（Retrieval-Augmented Generation）サポート

**重要**: agents-mdは、インテリジェントなセマンティック検索とマルチレベルインデックスを通じて**高度なRAG機能**をサポートします。これはトークン使用量を大幅に削減する強力な機能です。

**⚠️ モデル要件**: RAGサポートには**エージェント対応モデル**が必要です。すべてのAIモデルがメモリ取得をインテリジェントに処理できるわけではありません - 基本的な完了モデルはセマンティック検索を実行したり、どのメモリを読み込むかについてインテリジェントな決定を行ったりしない場合があります。

**動作方法**:
- **マルチレベルインデックス**: 即座のアクセスのためのインデックス優先ルックアップ
- **セマンティック検索**: 関連メモリを見つけるための自然言語クエリ
- **選択的読み取り**: 関連セクションのみがコンテキストに読み込まれます
- **トークン最適化**: ファイル全体を読み込む場合と比較して80-95%のトークン削減

**利点**:
- ✅ **トークン使用量の削減**: 関連メモリのみがコンテキストに読み込まれます
- ✅ **インテリジェントな取得**: エージェントはコンテキストを理解し、関連情報を自動的に取得
- ✅ **高速アクセス**: マルチレベルインデックスにより即座のルックアップが可能
- ✅ **スケーラブル**: 大規模なメモリデータベースを効率的に処理

**プロンプト例**:
```
What patterns did we establish for error handling in this project?
Check memory for previous solutions to similar issues.
What architectural decisions were made about the API design?
```

エージェントは自動的に：
1. セマンティックタグ/キーワードのインデックスファイルを確認
2. セマンティック検索を使用して関連ファイルを見つける
3. 関連セクションのみを選択的に読み取る
4. トークン使用量を最小化しながら精度を最大化

### メモリ使用のプロンプト例

メモリシステムと対話するために使用できる実用的なプロンプト例を以下に示します：

#### トピックとパターンの取得
```
What topics are documented in memory for this project?
Show me all the patterns we've established for this project.
What are the documented topics in the knowledge/ directory?
List all architectural patterns we've documented.
```

#### 特定の情報の検索
```
What did we decide about error handling in this project?
Check memory for how we handle authentication.
What patterns exist for API integration?
Find previous solutions to similar problems.
```

#### ユーザー設定の確認
```
What are my preferences for this project?
Check common preferences that apply to all projects.
What project-specific preferences are set?
```

#### アーキテクチャ決定のレビュー
```
What architectural decisions were made for this project?
Show me the architecture documentation from memory.
What design patterns are we using?
```

#### セッションサマリーの検索
```
What work was done in recent sessions?
Show me the last few session summaries.
What was completed in the last week?
```

#### プロジェクトステータスの確認
```
What's the current status of this project?
Show me recent fixes and updates.
What are the known issues and their solutions?
```

これらのプロンプトはすべて、エージェントがRAG技術を使用してメモリファイルをインテリジェントに検索し、トークン使用量を最小化しながら正確なコンテキストを提供するようにトリガーします。

### メモリファイルタイプ

- **知識ファイル** (`knowledge/topic_name.md`): パターンとアーキテクチャの継続的なドキュメント
- **セッションアーカイブ** (`sessions/YYYY-MM/YYYY-MM-DD_summary.md`): 統合された作業セッション
- **インデックスファイル** (`index.json`, `index.md`): 高速ルックアップとクイックリファレンス

## メモリシステムドキュメント

- **メモリシステム**: メモリ固有のドキュメントについては`_agents-md/memory/`を参照
  - **組織化**: `_agents-md/memory/organization.md` - メモリ管理ルール
  - **RAG**: `_agents-md/memory/rag.md` - RAG戦略とトークン最適化
  - **プラットフォーム**: `_agents-md/memory/platform.md` - プラットフォーム固有のパスとツール
- **テンプレート**: ワークフローテンプレートについては`templates/`を参照
  - **シンプルワークフロー**: クイックな日次ログ用の`templates/AGENTS.md.simple`と`templates/GLOBAL.md`
  - **テンプレートガイド**: `templates/README.md` - どのワークフローを使用するか

## メモリシステムの初期化と手動同期

### メモリ初期化プロンプト

プロジェクトのメモリを手動で初期化する場合は、このプロンプトを使用します：

```
Initialize memory for this project. Create the memory structure in the configured memory directory, including index files and initial knowledge files documenting the project architecture and patterns.
```

### 手動メモリ同期プロンプト

エージェントは自動的にメモリを同期しますが、以下で手動でトリガーできます：

```
Sync memory for this project. Update index files, consolidate recent sessions if needed, and ensure index.json is synchronized with actual files in knowledge/ and sessions/ directories.
```

### メモリ更新プロンプト

現在のプロジェクトステータスでメモリを更新するには：

```
Update project memory with current status. Document recent changes, update index files, and sync any new patterns or architectural decisions.
```

## メモリシステムプラットフォームサポート

メモリシステムは、プラットフォーム固有の最適化で複数のプラットフォームをサポートします：

- **macOS**: クラウドストレージ検出、Spotlight検索統合
- **Linux**: ファイルシステム固有の最適化、効率的な検索ツール
- **Windows**: PowerShell統合、WSLサポート

プラットフォーム固有のドキュメントについては`_agents-md/memory/platform.md`を参照してください。

## メモリシステムのセキュリティ

⚠️ **重要**: プライベートメモリ（`{MEMORY_DIR}/secure/`）には機密情報が含まれます：
- プライベートメモリファイルをバージョン管理にコミットしないでください
- 応答で機密データを常にマスクしてください
- 明示的に必要な場合のみアクセスしてください
- セキュリティプロトコルについては`_agents-md/memory/organization.md`を参照してください

## ライセンス

MIT License - 詳細については[LICENSE](LICENSE)ファイルを参照してください。

---

## メモリシステムの比較

### 主な改善点

**基本的なファイルベースメモリとの比較**:
- ✅ 高速ルックアップのためのマルチレベルインデックス
- ✅ RAG最適化取得（80-95%のトークン削減）
- ✅ プラットフォーム固有の最適化
- ✅ インテリジェントなセマンティック検索

**データベースベースメモリとの比較**:
- ✅ 外部依存関係なし
- ✅ 人間が読めるファイル
- ✅ バージョン管理に適している
- ✅ 簡単なバックアップと移行

**以前のシステムとの比較**:
- ✅ セマンティックタグによる改善されたRAGサポート
- ✅ より良いトークン最適化戦略
- ✅ マルチプラットフォームサポート
- ✅ インデックスによる高速取得

## プロジェクトロードマップ

**agents-md**は進化するシステムのコレクションです。将来の追加には以下が含まれます：

- 実務経験に基づく追加システム
- システム間の統合パターン
- ベストプラクティスとワークフロー
- コミュニティ貢献システム（レビューと品質基準の対象）

各新しいシステムは同じ原則に従います：本番テスト済み、十分にドキュメント化、モジュール化、エージェント互換。

## 貢献

これは個人プロジェクトですが、提案や改善を歓迎します。貢献がMITライセンスと帰属を維持することを確認してください。

## 謝辞

メモリシステムは、[Rudel, inc.](https://rudel.jp)での作業中に作成・開発された以前のメモリシステム設計に触発されました。基礎となる概念とアーキテクチャパターンは、このオープンソース実装のために改良・適応されました。

## 著者

Paulus Ery Wasito Adhi (paupawsan@gmail.com)

