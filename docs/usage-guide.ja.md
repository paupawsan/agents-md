<!--
Copyright (c) 2025 Paulus Ery Wasito Adhi paupawsan@gmail.com

Licensed under the MIT License. See LICENSE file for details.
-->

# 使用ガイド

このガイドでは、開発ワークフローでagents-mdシステムを効果的に使用する方法を説明します。メモリシステムとクリティカルシンキングフレームワークの両方をカバーします。

## メモリ構造

メモリシステムは情報を3つのカテゴリに整理します：

### 1. プロジェクト固有メモリ (`{MEMORY_DIR}/[project-name]/`)
- **目的**: 現在のプロジェクトに固有の知識
- **内容**:
  - プロジェクトアーキテクチャの決定 → `context.md`
  - プロジェクト固有のパターンと修正 → `topic/topic_name.md`
  - 作業セッション → `session/YYYY-MM/YYYY-MM-DD_feature.md`
  - プロジェクト固有の設定 → `topic/preferences.md`
  - インデックスファイル → `memories.json`
- **アクセス**: このプロジェクトで作業する場合に自動的に使用される

### 2. 共通メモリ (`{MEMORY_DIR}/common/`)
- **目的**: ユーザー設定とプロジェクト横断パターン
- **内容**:
  - ユーザー設定（すべてのプロジェクトに適用） → `preferences.md`
  - プロジェクト横断パターン → `patterns.md`
  - グローバル設定と構成
  - ユーザー作業フロー
- **アクセス**: すべてのプロジェクトで利用可能

### 3. プライベートメモリ (`{MEMORY_DIR}/private/`) ⚠️
- **目的**: 機密情報の保存
- **内容**:
  - 認証情報 → `credentials.md`
  - 個人情報 → `personal_info.md`
  - APIキー、パスワード、トークン
  - 機密設定
- **⚠️ 重要**: プライベートメモリファイルをバージョン管理にコミットしない
- **⚠️ セキュリティ**: 明示的に必要な場合にのみアクセス、機密データは応答でマスクされる

## エージェントがメモリを使用する方法

エージェントはほとんどのメモリ操作を自動的に処理します：

### 自動メモリ管理
- **重要なタスクやパターンの学習後にメモリを同期**
- **コンテキストが失われたり不明瞭な場合にメモリを確認**
- **新しい知識を作成したりセッションを作成したりする場合にインデックスファイルを更新**
- **関連するセッションを統合してクリーンな組織を維持**
- **RAGを使用して関連するメモリのみを取得し、トークン使用量を最小化**

### 手動メモリ操作（必要時）

#### メモリ初期化
```
このプロジェクトのメモリを初期化してください。設定されたメモリディレクトリにメモリ構造を作成し、プロジェクトアーキテクチャとパターンを文書化するインデックスファイルと初期ナレッジファイルを含めてください。
```

#### 手動メモリ同期
```
このプロジェクトのメモリを同期してください。インデックスファイルを更新し、必要に応じて最近のセッションを統合し、memories.jsonがtopic/とsession/ディレクトリの実際のファイルと同期されていることを確認してください。
```

#### メモリ更新
```
現在のステータスでプロジェクトメモリを更新してください。最近の変更を文書化し、インデックスファイルを更新し、新しいパターンやアーキテクチャ決定を同期してください。
```

## RAG（検索拡張生成）機能

メモリシステムは高度なRAG機能を使用してインテリジェントな情報検索を行います：

### マルチレベルRAG戦略

1. **インデックス検索** (~100-500トークン)
   - `memories.json`でタグ/キーワードを確認
   - 最速、最低コストの方法

2. **セマンティック検索** (~200-1000トークン)
   - メモリディレクトリでセマンティック検索を使用
   - 自然言語クエリ

3. **ヘッダースキャン** (~50-200トークン)
   - ファイルヘッダーをスキャンして関連セクションを特定
   - 特定のトピックを迅速に特定

4. **選択的読み取り** (~200-2000トークン)
   - offset/limitで特定されたセクションのみを読み取り
   - 大きなファイル全体の読み込みを回避

### トークン最適化

**常に**:
- 検索前にインデックス（`memories.json`）を確認
- ファイルを読み取る前にセマンティック検索を使用
- コンテンツを読み取る前にヘッダーをスキャン
- offset/limitで選択的に読み取る

**しない**:
- スキャンなしで大きなファイル全体（>500行）を読み取る
- すべてのメモリファイルを同時に読み込む
- インデックスファイルをスキップする

### 利点
- ✅ **80-95%のトークン削減**: インデックス優先アプローチ vs 完全検索
- ✅ **70-90%削減**: 選択的読み取り vs 完全ファイル
- ✅ **50-70%削減**: ヘッダーナビゲーション vs 完全ファイル
- ✅ **インテリジェントな検索**: エージェントはコンテキストを理解し、関連情報を自動的に取得
- ✅ **スケーラブル**: 大規模メモリデータベースを効率的に処理

## プロンプト例

メモリシステムを操作するための実用的なプロンプト例：

### トピックとパターンの取得
```
このプロジェクトのメモリにどのようなトピックが文書化されていますか？
このプロジェクトで確立したすべてのパターンを見せてください。
topic/ディレクトリに文書化されているトピックは何ですか？
文書化したすべてのアーキテクチャパターンをリストアップしてください。
```

### 特定の情報の検索
```
このプロジェクトでエラーハンドリングについて何を決定しましたか？
認証の処理方法についてメモリを確認してください。
API統合のためのパターンは何がありますか？
類似の問題に対する以前の解決策を見つけてください。
```

### ユーザー設定の確認
```
このプロジェクトの私の設定は何ですか？
すべてのプロジェクトに適用される共通設定を確認してください。
プロジェクト固有の設定は何が設定されていますか？
```

### アーキテクチャ決定の確認
```
このプロジェクトでどのようなアーキテクチャ決定が行われましたか？
メモリからアーキテクチャドキュメントを見せてください。
どのデザインパターンを使用していますか？
```

### セッションサマリの検索
```
最近のセッションでどのような作業が行われましたか？
最後のいくつかのセッションサマリを見せてください。
先週何が完了しましたか？
```

### プロジェクトステータスの確認
```
このプロジェクトの現在のステータスは何ですか？
最近の修正と更新を見せてください。
既知の問題とその解決策は何ですか？
```

### 新しいパターンの学習
```
このパターンを覚えてください：[パターンを説明]
このアーキテクチャ決定を文書化してください：[決定を説明]
これをプロジェクト知識に追加してください：[知識を説明]
```

## メモリファイルタイプ

### トピックファイル (`topic/topic_name.md`)
- **目的**: パターンとアーキテクチャの継続的なドキュメント
- **構造**: セマンティックタグとキーワードを含むMarkdownファイル
- **使用法**: 時間の経過とともに進化する長期知識
- **場所**: `{MEMORY_DIR}/[project-name]/topic/` または `{MEMORY_DIR}/common/patterns.md`

### セッションアーカイブ (`session/YYYY-MM/YYYY-MM-DD_feature.md`)
- **目的**: 時間で整理された作業セッションの統合
- **構造**: 完了した作業の時間別サマリー
- **使用法**: いつ何が行われたかの歴史的参照
- **場所**: `{MEMORY_DIR}/[project-name]/session/YYYY-MM/`

### インデックスファイル (`memories.json`, `context.md`)
- **目的**: 高速検索とクイックリファレンス
- **構造**: 機械可読JSONインデックスと人間可読コンテキスト
- **使用法**: メモリメタデータへの即時アクセス
- **場所**: `{MEMORY_DIR}/[project-name]/memories.json` と `context.md`

## ワークフローオプション

### 構造化ワークフロー（複雑なプロジェクトに推奨）
- **最適**: 大規模プロジェクト、チームコラボレーション、複雑なアーキテクチャ
- **機能**: トピック、セッション、インデックス作成を含むフルメモリシステム
- **構造**: クロスリファレンス付き整理された知識ベース
- **保守**: 定期的な統合とインデックス作成が必要

### シンプルワークフロー（ビベコーディングと実験用）
- **最適**: クイックプロトタイプ、個人実験、小規模プロジェクト
- **機能**: 毎日のログ記録用の単一ファイルテンプレート
- **構造**: 迅速な反復に焦点を当てた最小限の整理
- **保守**: オーバーヘッドが低い、保守が容易

`templates/README.md` で適切なワークフローの選択に関するガイダンスを参照してください。

## ベストプラクティス

### メモリを使用する場合
- **新規プロジェクト**: パターンを確立するためにメモリを初期化
- **問題解決**: 以前の解決策をメモリで確認
- **アーキテクチャ決定**: 重要な選択を文書化
- **パターン認識**: 繰り返される解決策から学習
- **知識転送**: プロジェクト間で洞察を共有

### メモリ保守
- **定期同期**: エージェントに自動同期を許可
- **手動確認**: エージェントが学んだことを定期的に確認
- **統合**: エージェントが断片化されたメモリを統合できるようにする
- **プライバシーチェック**: 機密情報がプライベートメモリに保存されていることを確認

### 効果的なプロンプト
- **具体的**: "APIエラーハンドリングについて何を決定したか？" vs "APIについて？"
- **コンテキストを含む**: 関連する場合にプロジェクト固有の詳細を含める
- **自然言語**: 同僚に尋ねるようにプロンプトを書く
- **フォローアップ**: 結果が期待通りでない場合は明確化を求める

## プライバシーとセキュリティ

### プライベートメモリ処理
- **自動検出**: エージェントが機密情報を自動的に検出するはず
- **手動オーバーライド**: 機密データをプライベートメモリに明示的に保存するためのプロンプトを使用
- **アクセス制御**: 必要な場合にのみプライベートメモリにアクセス
- **バージョン管理**: Gitにプライベートメモリファイルをコミットしない

### セキュリティベストプラクティス
- **ローカル保存**: メモリはあなたのマシンに残る
- **外部送信なし**: メモリを外部サービスに送信するAPI呼び出しなし
- **ファイル権限**: OSレベルの権限を使用してアクセスを制御
- **暗号化**: 機密メモリファイルを暗号化することを検討

## プラットフォーム固有機能

メモリシステムにはプラットフォーム固有の最適化が含まれます：

### macOS
- **クラウドストレージ検出**: iCloud、Google Driveを自動的に検出
- **Spotlight統合**: 検索機能の強化
- **パス解決**: macOS固有のパス規則の処理

### Linux
- **ファイルシステム最適化**: 効率的なファイル操作
- **検索ツール**: 最適化された検索ユーティリティの使用
- **権限処理**: 適切なLinux権限管理

### Windows
- **PowerShell統合**: コマンド実行の強化
- **WSLサポート**: Windows Subsystem for Linux内での動作
- **パス解決**: Windows固有のパスとUNCの処理

## メモリ問題のトラブルシューティング

### メモリが使用されていない
- **セットアップの確認**: `AGENTS.md` が適切に構成されていることを確認
- **ワークスペースアクセス**: メモリディレクトリがワークスペースにあることを確認
- **権限**: エージェントコマンド権限を確認
- **モデル機能**: エージェント対応モデルを使用していることを確認

### 誤った情報が取得された
- **プロンプトの明確化**: プロンプトをより具体的にする
- **メモリの質**: 保存された情報を確認して修正
- **インデックス更新**: 必要に応じてインデックスを手動更新
- **統合**: エージェントが断片化されたメモリを統合できるようにする

### メモリファイルが作成されない
- **ディレクトリアクセス**: メモリディレクトリが書き込み可能であることを確認
- **コマンド権限**: エージェントがファイル操作を実行できることを確認
- **パス設定**: `AGENTS.md` のパスがシステムと一致することを確認
- **ワークスペース設定**: ワークスペースにメモリディレクトリが含まれていることを確認

### パフォーマンス問題
- **大規模メモリベース**: 古いセッションを統合することを検討
- **インデックス破損**: 必要に応じてインデックスを再構築
- **プラットフォーム問題**: プラットフォーム固有の最適化を確認
- **トークン制限**: より具体的なクエリを使用してコンテキストサイズを減らす

## 高度な使用法

### カスタムメモリ組織
- **デフォルトのオーバーライド**: カスタムディレクトリ構造を構成
- **複数のメモリベース**: 異なるコンテキストで異なるメモリディレクトリを使用
- **統合**: 他のメモリシステムやデータベースと統合

### メモリアナリティクス
- **パターンの確認**: どのような種類の情報が保存されているかを分析
- **使用統計**: メモリアクセスパターンを追跡
- **品質評価**: メモリ精度を定期的に確認
- **最適化**: ストレージと検索戦略を改良

### 他のツールとの統合
- **バージョン管理**: メモリファイルはGitワークフローで動作
- **ドキュメント**: プロジェクトドキュメントとしてメモリを使用
- **知識共有**: チーム共有のためにメモリをエクスポート
- **バックアップ**: メモリディレクトリの定期バックアップ戦略

## クリティカルシンキングシステムの使用

クリティカルシンキングフレームワークは、メモリシステムと自動的に連携して、インテリジェントでコンテキストを意識した意思決定を提供します。

### 動作方法

クリティカルシンキングシステムは自動的に：
- **リスクを評価** コンテキストに基づいて（セキュリティ重要 vs プロトタイピング）
- **事実を検証** 主張や推奨を行う前に
- **仮定に挑戦** 適切な場合に
- **コミュニケーションスタイルを適応** 聴衆に基づいて（専門家 vs 非技術者）

### 活性化タイミング

**高リスクシナリオ**（最大限の検証）：
- 銀行/金融アプリケーション
- ヘルスケアシステム
- 本番データベース変更
- セキュリティ重要コード
- 決済処理

**低リスクシナリオ**（柔軟なアプローチ）：
- クイックプロトタイプ
- デバッグセッション
- ドキュメント更新
- 実験的機能
- 個人プロジェクト

### クリティカルシンキングの使用

システムは自動的に動作しますが、ガイドできます：

**検証を要求**:
```
実装前にこのアプローチを検証してください
このライブラリがまだメンテナンスされているか確認してください
これが私たちのユースケースに最適なベストプラクティスであることを確認してください
```

**マルチ視点分析を要求**:
```
ユーザーエクスペリエンス、パフォーマンス、保守性の複数の角度からこれを検討してください
このアプローチのトレードオフは何ですか？
影響を考えてください
```

**証拠に基づく推論を要求**:
```
この決定を裏付ける証拠は何ですか？
検討すべき代替案はありますか？
このアプローチについての私の仮定に挑戦してください
```

### メモリとの統合

クリティカルシンキングはメモリシステムパターンを使用します：
- 保存されたアーキテクチャ決定を参照
- 文書化された設定を考慮
- 過去の決定から学習
- プロジェクト固有のパターンを適用

**例**:
```
この機能にTypeScriptとJavaScriptのどちらを使用すべきですか？
```
エージェントは以下を実行します：
1. プロジェクトパターン/設定についてメモリを確認
2. コンテキストを考慮（プロトタイプ vs 本番）
3. 証拠に基づく推奨を提供
4. TypeScript使用に関する保存された決定を参照

## ヘルプの取得

問題が発生した場合：
1. [セットアップガイド](setup-guide.md) で設定問題を確認
2. [メモリシステムテスト](memory-system-testing/) で検証手順を確認
3. [クリティカルシンキングテスト](critical-thinking-testing/) で検証手順を確認
4. `_agents-md/memory/` と `_agents-md/critical-thinking/` の詳細ドキュメントを確認
5. AIアシスタントに助けを求める（必要な機能をサポートしていることを確認）

agents-mdシステムは、あなたの作業スタイルとプロジェクトのニーズに適応するインテリジェントで文脈を意識した知識管理と意思決定を提供することで、開発ワークフローを強化するように設計されています。
